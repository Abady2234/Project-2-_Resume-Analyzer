# -*- coding: utf-8 -*-
"""Welcome To Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

from google.colab.output import eval_js
print(eval_js("google.colab.kernel.proxyPort(5000)"))
#تحملها لحالها
#########################################################

!pip install pyngrok
from pyngrok import ngrok

# استبدل "your_authtoken" بـ authtoken الخاص بك الذي حصلت عليه من حساب ngrok
ngrok.set_auth_token("2wEkBqsKb8XF2a3o6DlKulUPQ7h_34PsjjtM23EqdaYRuVccA")

# تشغيل نفق على المنفذ 5000
public_url = ngrok.connect(5000)
print(f' * ngrok tunnel "http://127.0.0.1:5000" -> "{public_url}"')
# تحملها لحالها
###############################################################

!pip install flask pyngrok python-docx PyPDF2

from google.colab.output import eval_js
from flask import Flask, render_template_string, request
from pyngrok import ngrok
import re
import tempfile
import PyPDF2
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# رابط التطبيق
print(eval_js("google.colab.kernel.proxyPort(5000)"))

# ngrok إعداد
ngrok.set_auth_token("2w0J57bndd9XKp34PSqCkzpklkb_3LxNSAryXKDVFo39PSYeb")
public_url = ngrok.connect(5000)
print(f' * Ngrok Tunnel: {public_url}')

# واجهة الموقع HTML (مضمنة داخل الكود)
html_code = """
<!DOCTYPE html>
<html>
<head>
    <title>Resume Analyzer</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 30px; background-color: #f8f9fa; }
        h1 { color: #343a40; }
        input[type="file"] { margin: 15px 0; }
        textarea { width: 100%; height: 200px; margin-top: 20px; padding: 10px; font-size: 14px; background-color: #ffffff; border: 1px solid #ced4da; border-radius: 4px; }
        .btn { background-color: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; }
        .btn:hover { background-color: #0056b3; }
        .result { margin-top: 30px; background-color: #e9ecef; padding: 20px; border-radius: 5px; white-space: pre-wrap; font-family: monospace; }
    </style>
</head>
<body>
    <h1>Upload your Resume</h1>
    <form method="POST" enctype="multipart/form-data">
        <label>Select Resume:</label><br>
        <input type="file" name="file" accept=".pdf, .docx" required><br><br>
        <button class="btn" type="submit">Upload</button>
    </form>

    {% if result %}
        <div class="result">
            <h3>Analysis Results</h3>
            <pre>{{ result }}</pre>
        </div>
    {% endif %}
</body>
</html>
"""
#################################
# إنشاء تطبيق Flask
app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def home():
    result = ""
    if request.method == 'POST':
        file = request.files['file']
        if file:
            result = process_resume(file)
    return render_template_string(html_code, result=result)

def process_resume(file):
    try:
        with tempfile.NamedTemporaryFile(delete=False) as temp_file:
            temp_file.write(file.read())
            file_path = temp_file.name

        text = extract_text_from_pdf(file_path)

        name = re.findall(r'(?:Name|Full Name)[\s:]*([\w\s]+)', text)
        name = name[0].strip() if name else "Name Not Found"

        email = re.findall(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}', text)
        email = email[0] if email else "Email Not Found"

        phone = re.findall(r'\b05\d{8}\b', text)
        phone_number = phone[0] if phone else "Phone Not Found"

        major = re.findall(r'\b(?:Computer Science|Engineering|Data Science|Mathematics|Business|Economics)\b', text, re.IGNORECASE)
        major_field = major[0] if major else "Major Not Found"

        skills = re.findall(r'\b(?:Python|Java|C\+\+|SQL|Machine Learning|Data Analysis|Excel|Tableau|JavaScript|Docker|AWS|Linux|OOP)\b', text, re.IGNORECASE)
        skills_str = " ".join(skills) if skills else "No skills found"

        analyzer = ResumeAnalyzer()
        results = analyzer.match_jobs(skills_str)

        output = f"**Name:** {name}\n"
        output += f"**Email:** {email}\n"
        output += f"**Phone:** {phone_number}\n"
        output += f"**Major:** {major_field}\n"
        output += f"**Skills:** {skills_str}\n\n"
        output += "**Matching Jobs:**\n"
        for job, score in results:
            output += f"- {job}: {score}%\n"

        return output
    except Exception as e:
        return f"An error occurred: {str(e)}"

def extract_text(file_path, filename):
    try:
        if filename.lower().endswith(".pdf"):
            with open(file_path, "rb") as f:
                reader = PyPDF2.PdfReader(f)
                return " ".join(page.extract_text() or "" for page in reader.pages)
        elif filename.lower().endswith(".docx"):
            doc = docx.Document(file_path)
            return " ".join(para.text for para in doc.paragraphs)
        else:
            raise Exception("Unsupported file type!")
    except Exception as e:
        return f"Error extracting text: {str(e)}"

class ResumeAnalyzer:
 def __init__(self):
        self.skills_list = [
            "Python", "Java", "C++", "JavaScript", "SQL",
            "Git", "Docker", "AWS", "Machine Learning",
            "Data Analysis", "Excel", "Tableau", "Linux , OOP "
        ]
        self.job_profiles = {
            'Data Scientist': ['Python', 'Machine Learning', 'Data Analysis', 'SQL'],
            'Web Developer': ['JavaScript', 'HTML', 'CSS', 'React','OOP'],
            'DevOps Engineer': ['Docker', 'AWS', 'Linux', 'CI/CD']
        }
        self.vectorizer = TfidfVectorizer()

 def match_jobs(self, skills_str):
    job_titles_skills = [' '.join(skills) for skills in self.job_profiles.values()]
    self.vectorizer.fit(job_titles_skills)

    results = []
    for job, required_skills in self.job_profiles.items():
        vectors = self.vectorizer.transform([skills_str, ' '.join(required_skills)])
        score = cosine_similarity(vectors[0:1], vectors[1:2])[0][0]
        results.append((job, round(score * 100, 2)))

    results.sort(key=lambda x: x[1], reverse=True)
    return results

# تشغيل التطبيق
if __name__ == '__main__':
    app.run()